{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BenchBuild Documentation BenchBuild is an open-source toolkit that helps with the management of case-studies used in software-driven empirical experiments. BenchBuild was specifically designed to make defined experiments reusable between different experiment setups. It mainly provides assistance with the following standard tasks found in empirical software experiments: Add a new case-study to an existing experiment setup. Add a new experiment to an existing body of case-studies. Design Philosophy BenchBuild is designed with the following main properties in mind. A case-study doesn't know its experiment If you add a new case-study, you should never have to rely on background information about the experiment you are about to run on it. A new case-study is only concerned with its own setup of dependencies and execution during its run-time. A case-study controls where and what can be intercepted by an experiment. An experiment doesn't know its case-studies Adding a new experiment never should have any knowledge about the case-studies it runs on. A new experiment takes care of intercepting the compilation process and/or the execution procedure of a given case-study. This only defines what is being done at the defined extension points at compile-time or run-time. Supported Python Versions BenchBuild supports Python 3.7 and 3.8. Main development is focused on Python 3.8, but an effort is made to support 3.7 as long as major distributions like Debian Linux only ship with 3.7 by default. Getting started See the Installation guide for help getting BenchBuild up and running quickly.","title":"BenchBuild Documentation"},{"location":"#benchbuild-documentation","text":"BenchBuild is an open-source toolkit that helps with the management of case-studies used in software-driven empirical experiments. BenchBuild was specifically designed to make defined experiments reusable between different experiment setups. It mainly provides assistance with the following standard tasks found in empirical software experiments: Add a new case-study to an existing experiment setup. Add a new experiment to an existing body of case-studies.","title":"BenchBuild Documentation"},{"location":"#design-philosophy","text":"BenchBuild is designed with the following main properties in mind.","title":"Design Philosophy"},{"location":"#a-case-study-doesnt-know-its-experiment","text":"If you add a new case-study, you should never have to rely on background information about the experiment you are about to run on it. A new case-study is only concerned with its own setup of dependencies and execution during its run-time. A case-study controls where and what can be intercepted by an experiment.","title":"A case-study doesn&#39;t know its experiment"},{"location":"#an-experiment-doesnt-know-its-case-studies","text":"Adding a new experiment never should have any knowledge about the case-studies it runs on. A new experiment takes care of intercepting the compilation process and/or the execution procedure of a given case-study. This only defines what is being done at the defined extension points at compile-time or run-time.","title":"An experiment doesn&#39;t know its case-studies"},{"location":"#supported-python-versions","text":"BenchBuild supports Python 3.7 and 3.8. Main development is focused on Python 3.8, but an effort is made to support 3.7 as long as major distributions like Debian Linux only ship with 3.7 by default.","title":"Supported Python Versions"},{"location":"#getting-started","text":"See the Installation guide for help getting BenchBuild up and running quickly.","title":"Getting started"},{"location":"CHANGELOG/","text":"(2021-09-15) Features environments: add an interactive mode for container runs. ( c03738cd ) log: add force_tty switch to control RichHandler. (#435) ( fe91f81c ) source: update git remote revisions. (#434) ( 6899f2de ) utils/run: add unbuffered watch commands ( 0b4bd04c ) Bug Fixes environments: pass format string to logging call (#427) ( bf52f27e ) logging: make rich log to stderr by default (#415) ( 7a59868e , closes #412 ) schema: silence SAWarning about caching (#428) ( f9d6ecab ) settings: BB_ENV is ignored when no config file is loaded\" (#414) ( 28d4c52f ) sources: do not use protocol class as ABC ( 2545684c ) 6.2 Bug Fixes use correct schema version ( beb9907e ) environments: notify the user, if image creation fails ( ab43787e ) project: do not track project classes twice ( 4991ed99 , closes #390 ) settings: unbreak test cases. ( 02745c46 ) consistent settings behavior. ( 25bfdd80 ) 6.1 Bug Fixes do not use global state to conffigure buildah/podman ( 34d0aa26 ) ci: typo. ( 93ca8ee4 ) cli/project: annotate print_layers ( 8d3b1531 ) add neutral element for multiplication with reduce ( 0bbf5664 ) environments: unshallow git clones before dissociating ( 21aac7ce ) remove left-over parameters ( 6f3b2a8e ) do not overwrite exported images. ( 31da2ad7 , closes #397 ) remove optional image name argument from podman load ( c9bb2357 , closes #398 ) reuse same status bar structure for all other cli subcommands ( 256252f8 ) mypy warnings ( 8f016d17 ) fix mypy/pylint annotations. ( 379114c3 ) split return turple and baild out on error ( 57d8e84c ) mypy warnings ( b514cc56 ) add missing type conversion ( 5211858c , closes #388 ) rework typing annotations for handlers ( 100773ca ) fix linter/mypy warnings ( 6d1b5e35 ) make Add & Copy layers hashable ( 2a38dced ) add missing sys import ( 8ca2cb37 ) import Protocol from typing_extensions, if python <= 3.8 ( 5d3577a7 ) handle 'None' for MaybeContainer return type ( 1dc0aeef ) deal with multi-line container ids ( fdfd5342 ) do not spawn the FromLayer ( 265c623e ) explicitly state remote registry location ( 84a591cc ) project: project registration for groups ( 6383d13e ) slurm: fix pylint/mypy ( ddc06db9 ) do not modify slurm_node_dir ( be33d9a8 ) sources: unshallow only when needed ( 6e0ae20c ) x264: use local name of source for lookup ( 754718fc , closes #356 ) Features tune down rich's custom log format ( 04fbe347 ) add support for --export and --import flags in containers ( c18b7199 ) cli/project: add details view for a single project ( 87c53e8d ) change project view to a condensed format ( 7af65f19 ) environments: just print env var name as error message ( b9044ef3 ) warn the user about too long paths for libpod ( 325b5003 ) enable debugging of failed image builds ( 4c0e5ccd ) provide more consistent output through rich ( 3982228d ) add 'rmi' subcommand to delete images. ( 80e239c6 ) make an error message stand out more clearly ( c5248f8a ) add g++ to base image ( e20c572c ) split image_exists into 2 implementations ( 73d76d38 ) split containers cli into 2 entitie ( 6c3167d6 ) add basic error handling to environments ( b711386e ) emit layer creation events ( 9a7fa149 ) print layer construction progress ( 404ac07e ) make layers hashable ( 36432f02 ) step-wise image construction ( f5100ec8 ) split Repositories and Unit of Work into 2 entities each ( 6b9b9cd2 ) add option to replace container images ( 33cdac30 , closes #372 ) slurm: support variable number of subcommand arguments ( 3df4cbd3 , closes #396 ) utils/slurm: add customizable SLURM templates ( 31022284 ) 6.0.1 (2020-12-29) Bug Fixes Avoid useless plugin spam when running with higher verbosity levels ( 258bed40 , closes #354 )","title":"Release Notes"},{"location":"CHANGELOG/#2021-09-15","text":"","title":"(2021-09-15)"},{"location":"CHANGELOG/#features","text":"environments: add an interactive mode for container runs. ( c03738cd ) log: add force_tty switch to control RichHandler. (#435) ( fe91f81c ) source: update git remote revisions. (#434) ( 6899f2de ) utils/run: add unbuffered watch commands ( 0b4bd04c )","title":"Features"},{"location":"CHANGELOG/#bug-fixes","text":"environments: pass format string to logging call (#427) ( bf52f27e ) logging: make rich log to stderr by default (#415) ( 7a59868e , closes #412 ) schema: silence SAWarning about caching (#428) ( f9d6ecab ) settings: BB_ENV is ignored when no config file is loaded\" (#414) ( 28d4c52f ) sources: do not use protocol class as ABC ( 2545684c )","title":"Bug Fixes"},{"location":"CHANGELOG/#62","text":"","title":"6.2"},{"location":"CHANGELOG/#bug-fixes_1","text":"use correct schema version ( beb9907e ) environments: notify the user, if image creation fails ( ab43787e ) project: do not track project classes twice ( 4991ed99 , closes #390 ) settings: unbreak test cases. ( 02745c46 ) consistent settings behavior. ( 25bfdd80 )","title":"Bug Fixes"},{"location":"CHANGELOG/#61","text":"","title":"6.1"},{"location":"CHANGELOG/#bug-fixes_2","text":"do not use global state to conffigure buildah/podman ( 34d0aa26 ) ci: typo. ( 93ca8ee4 ) cli/project: annotate print_layers ( 8d3b1531 ) add neutral element for multiplication with reduce ( 0bbf5664 ) environments: unshallow git clones before dissociating ( 21aac7ce ) remove left-over parameters ( 6f3b2a8e ) do not overwrite exported images. ( 31da2ad7 , closes #397 ) remove optional image name argument from podman load ( c9bb2357 , closes #398 ) reuse same status bar structure for all other cli subcommands ( 256252f8 ) mypy warnings ( 8f016d17 ) fix mypy/pylint annotations. ( 379114c3 ) split return turple and baild out on error ( 57d8e84c ) mypy warnings ( b514cc56 ) add missing type conversion ( 5211858c , closes #388 ) rework typing annotations for handlers ( 100773ca ) fix linter/mypy warnings ( 6d1b5e35 ) make Add & Copy layers hashable ( 2a38dced ) add missing sys import ( 8ca2cb37 ) import Protocol from typing_extensions, if python <= 3.8 ( 5d3577a7 ) handle 'None' for MaybeContainer return type ( 1dc0aeef ) deal with multi-line container ids ( fdfd5342 ) do not spawn the FromLayer ( 265c623e ) explicitly state remote registry location ( 84a591cc ) project: project registration for groups ( 6383d13e ) slurm: fix pylint/mypy ( ddc06db9 ) do not modify slurm_node_dir ( be33d9a8 ) sources: unshallow only when needed ( 6e0ae20c ) x264: use local name of source for lookup ( 754718fc , closes #356 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_1","text":"tune down rich's custom log format ( 04fbe347 ) add support for --export and --import flags in containers ( c18b7199 ) cli/project: add details view for a single project ( 87c53e8d ) change project view to a condensed format ( 7af65f19 ) environments: just print env var name as error message ( b9044ef3 ) warn the user about too long paths for libpod ( 325b5003 ) enable debugging of failed image builds ( 4c0e5ccd ) provide more consistent output through rich ( 3982228d ) add 'rmi' subcommand to delete images. ( 80e239c6 ) make an error message stand out more clearly ( c5248f8a ) add g++ to base image ( e20c572c ) split image_exists into 2 implementations ( 73d76d38 ) split containers cli into 2 entitie ( 6c3167d6 ) add basic error handling to environments ( b711386e ) emit layer creation events ( 9a7fa149 ) print layer construction progress ( 404ac07e ) make layers hashable ( 36432f02 ) step-wise image construction ( f5100ec8 ) split Repositories and Unit of Work into 2 entities each ( 6b9b9cd2 ) add option to replace container images ( 33cdac30 , closes #372 ) slurm: support variable number of subcommand arguments ( 3df4cbd3 , closes #396 ) utils/slurm: add customizable SLURM templates ( 31022284 )","title":"Features"},{"location":"CHANGELOG/#601-2020-12-29","text":"","title":"6.0.1 (2020-12-29)"},{"location":"CHANGELOG/#bug-fixes_3","text":"Avoid useless plugin spam when running with higher verbosity levels ( 258bed40 , closes #354 )","title":"Bug Fixes"},{"location":"advanced/","text":"SLURM BenchBuild supports a high-level integration with the SLURM cluster resource manager. An experiment setup can be exported as a SLURM bash script. Assuming you have access to a configured benchbuid environment on the SLURM cluster, you can provide the SLURM script to the sbatch command and have your experiment run on the cluster environment. Basics TODO Template customization This customization is not recommended for the default use-case. However, you might run in a situation where the existing cluster-environment requires a more complicated setup than BenchBuild can provide. You can customize the template that is used for the SLURM script using a modified copy of the base template BenchBuild uses (see benchbuild/res/misc/slurm.sh.inc ). The customized template can be configured using the configuration option BB_SLURM_TEMPLATE . If BenchBuild detects that the provided value points to an existing file in your filesystem, it will load it. If you change the setting and BenchBuild cannot find a file there, no script will be generated. No validation of the template will be done, use at your own risk.","title":"SLURM"},{"location":"advanced/#slurm","text":"BenchBuild supports a high-level integration with the SLURM cluster resource manager. An experiment setup can be exported as a SLURM bash script. Assuming you have access to a configured benchbuid environment on the SLURM cluster, you can provide the SLURM script to the sbatch command and have your experiment run on the cluster environment.","title":"SLURM"},{"location":"advanced/#basics","text":"TODO","title":"Basics"},{"location":"advanced/#template-customization","text":"This customization is not recommended for the default use-case. However, you might run in a situation where the existing cluster-environment requires a more complicated setup than BenchBuild can provide. You can customize the template that is used for the SLURM script using a modified copy of the base template BenchBuild uses (see benchbuild/res/misc/slurm.sh.inc ). The customized template can be configured using the configuration option BB_SLURM_TEMPLATE . If BenchBuild detects that the provided value points to an existing file in your filesystem, it will load it. If you change the setting and BenchBuild cannot find a file there, no script will be generated. No validation of the template will be done, use at your own risk.","title":"Template customization"},{"location":"advanced/cli/","text":"CLI --force-watch-unbuffered : This disables buffering from watched commands. This can help with tools that call benchbuild and use their own output buffering.","title":"Cli"},{"location":"advanced/cli/#cli","text":"--force-watch-unbuffered : This disables buffering from watched commands. This can help with tools that call benchbuild and use their own output buffering.","title":"CLI"},{"location":"basics/","text":"Installation The installation instructions are tested against Ubuntu 20.04 for Python 3.7 and Python 3.8. The particular commands required for installation depend on your setup. The dependencies below are not always mandatory, if they are not used. Requirements Dependency Minimum Version Notes Python 3.7 libpq 9.6 Required by psycopg2. libfuse 2.9.9 If uchroot is used. unionfs-fuse 1.0 If unionfs support is used. slurm-llnl 18.08 If slurm support is used. PostgreSQL The library dependency libpq is always need right now, because we make use of psycopg2 features internally. It is planned to get rid of this dependency in the future. FUSE BenchBuild can make use of unionfs and libfuse . This is often used in conjunction with a tool named uchroot which provides legacy support for user-space containers. This will be obsolete as soon as podman / buildah based OCI container support is considered stable. SLURM The cluster management software slurm is only required by 'name', i.e., we have to be able to import the binaries as python objects in benchbuild. As an alternative to installing slurm on your machine, you can always provide symlinks to /bin/true to the commands sbatch and srun . The minimum version should signal the minimum features set expected by BenchBuild when generating a slurm batch script. Benchbuild BenchBuild is released via pip and can be installed on your system as follows: pip install benchbuild [1] ( ) (b a s h) ( ) If you want to isolate BenchBuild from the rest of your system packages, you can install it in a dedicated virtual environment. virtualenv -ppython3 <venv_path> source <venv_path>/bin/activate pip3 install benchbuild [2] ( ) (b a s h) ( ) Bootstrapping BenchBuild provides a bootstrap procedure that checks a few key binaries on your system and tries to assist you in installation of any necessary binaries.","title":"Installation"},{"location":"basics/#installation","text":"The installation instructions are tested against Ubuntu 20.04 for Python 3.7 and Python 3.8. The particular commands required for installation depend on your setup. The dependencies below are not always mandatory, if they are not used.","title":"Installation"},{"location":"basics/#requirements","text":"Dependency Minimum Version Notes Python 3.7 libpq 9.6 Required by psycopg2. libfuse 2.9.9 If uchroot is used. unionfs-fuse 1.0 If unionfs support is used. slurm-llnl 18.08 If slurm support is used.","title":"Requirements"},{"location":"basics/#postgresql","text":"The library dependency libpq is always need right now, because we make use of psycopg2 features internally. It is planned to get rid of this dependency in the future.","title":"PostgreSQL"},{"location":"basics/#fuse","text":"BenchBuild can make use of unionfs and libfuse . This is often used in conjunction with a tool named uchroot which provides legacy support for user-space containers. This will be obsolete as soon as podman / buildah based OCI container support is considered stable.","title":"FUSE"},{"location":"basics/#slurm","text":"The cluster management software slurm is only required by 'name', i.e., we have to be able to import the binaries as python objects in benchbuild. As an alternative to installing slurm on your machine, you can always provide symlinks to /bin/true to the commands sbatch and srun . The minimum version should signal the minimum features set expected by BenchBuild when generating a slurm batch script.","title":"SLURM"},{"location":"basics/#benchbuild","text":"BenchBuild is released via pip and can be installed on your system as follows: pip install benchbuild [1] ( ) (b a s h) ( ) If you want to isolate BenchBuild from the rest of your system packages, you can install it in a dedicated virtual environment. virtualenv -ppython3 <venv_path> source <venv_path>/bin/activate pip3 install benchbuild [2] ( ) (b a s h) ( )","title":"Benchbuild"},{"location":"basics/#bootstrapping","text":"BenchBuild provides a bootstrap procedure that checks a few key binaries on your system and tries to assist you in installation of any necessary binaries.","title":"Bootstrapping"},{"location":"basics/actions/","text":"Actions Actions are used to declare the workflow of an experiment. BenchBuild provides a set of default actions that should suit most experiments. A new experiment can define a new set of actions that should be used per project, or use those defaults. Customize actions Whenever you define a new expeirment, you have to provide an implementation for def actions_for_project(self, project: 'Project') . This implementation usually configures extensions on the project and returns a set of actions that should be run during execution. Example: def actions_for_project(self, project: 'Project'): project.runtime_extension = time.RunWithTime( run.RuntimeExtensions(project, self)) project.runtime_extension = time.WithTimeout( run.RunCompiler(project, self)) return self.default_runtime_actions(project) [1] ( ) ({ p y t h o n }) ( ) This takes care of compiling, running and cleanup during experiment execution. Available Actions The following actions are available out of the box. You can define your own actions at any time Step (Base) Clean MakeBuildDir Compile Run Echo Any (Group) Experiment (Any, Group) RequireAll (Group) CleanExtra ProjectEnvironment SetProjectVersion This action provides you with a way to change the source version used inside the build directory of this project. During initialization, each project is assigned a variant that determines the source versions that will be checked out into the build directory. Sometimes it can be useful to do comparisons of different source revisions inside a single experiment run. This can be achieved using SetProjectVersion . Usage: from benchbuild.source.base import RevisionStr from benchbuild.utils import actions as a ... git_commit_hash = 'abcdefgh' actions = [ a.Clean(project), a.MakeBuildDir(project), # This uses the default variant of the project (not necessarily 'abcdefgh') a.ProjectEnvironment(project), a.Compile(project), a.Run(project), # From here we will work with git sources set to 'abcdefgh' a.SetProjectVersion(project, RevisionStr(git_commit_hash)) a.Compile(project), a.Run(project) ] [2] ( ) ({ p y t h o n }) ( ) The match is done on all(!) sources of the project. If you happen to find a revision string twice in different souces, both will be checked out in the build directory. The match is done exact and matches agains the source.versions() output of a source. Only sources that are marked as expandable ( source.is_expandable ) will be checked.","title":"Actions"},{"location":"basics/actions/#actions","text":"Actions are used to declare the workflow of an experiment. BenchBuild provides a set of default actions that should suit most experiments. A new experiment can define a new set of actions that should be used per project, or use those defaults.","title":"Actions"},{"location":"basics/actions/#customize-actions","text":"Whenever you define a new expeirment, you have to provide an implementation for def actions_for_project(self, project: 'Project') . This implementation usually configures extensions on the project and returns a set of actions that should be run during execution. Example: def actions_for_project(self, project: 'Project'): project.runtime_extension = time.RunWithTime( run.RuntimeExtensions(project, self)) project.runtime_extension = time.WithTimeout( run.RunCompiler(project, self)) return self.default_runtime_actions(project) [1] ( ) ({ p y t h o n }) ( ) This takes care of compiling, running and cleanup during experiment execution.","title":"Customize actions"},{"location":"basics/actions/#available-actions","text":"The following actions are available out of the box. You can define your own actions at any time","title":"Available Actions"},{"location":"basics/actions/#step-base","text":"","title":"Step (Base)"},{"location":"basics/actions/#clean","text":"","title":"Clean"},{"location":"basics/actions/#makebuilddir","text":"","title":"MakeBuildDir"},{"location":"basics/actions/#compile","text":"","title":"Compile"},{"location":"basics/actions/#run","text":"","title":"Run"},{"location":"basics/actions/#echo","text":"","title":"Echo"},{"location":"basics/actions/#any-group","text":"","title":"Any (Group)"},{"location":"basics/actions/#experiment-any-group","text":"","title":"Experiment (Any, Group)"},{"location":"basics/actions/#requireall-group","text":"","title":"RequireAll (Group)"},{"location":"basics/actions/#cleanextra","text":"","title":"CleanExtra"},{"location":"basics/actions/#projectenvironment","text":"","title":"ProjectEnvironment"},{"location":"basics/actions/#setprojectversion","text":"This action provides you with a way to change the source version used inside the build directory of this project. During initialization, each project is assigned a variant that determines the source versions that will be checked out into the build directory. Sometimes it can be useful to do comparisons of different source revisions inside a single experiment run. This can be achieved using SetProjectVersion . Usage: from benchbuild.source.base import RevisionStr from benchbuild.utils import actions as a ... git_commit_hash = 'abcdefgh' actions = [ a.Clean(project), a.MakeBuildDir(project), # This uses the default variant of the project (not necessarily 'abcdefgh') a.ProjectEnvironment(project), a.Compile(project), a.Run(project), # From here we will work with git sources set to 'abcdefgh' a.SetProjectVersion(project, RevisionStr(git_commit_hash)) a.Compile(project), a.Run(project) ] [2] ( ) ({ p y t h o n }) ( ) The match is done on all(!) sources of the project. If you happen to find a revision string twice in different souces, both will be checked out in the build directory. The match is done exact and matches agains the source.versions() output of a source. Only sources that are marked as expandable ( source.is_expandable ) will be checked.","title":"SetProjectVersion"},{"location":"basics/configuration/","text":"","title":"Configuration"},{"location":"basics/containers/","text":"Benchbuild allows the definition of container images to define the base system all experiment runs run in for a given project. Usage If you want to run an experiment inside the project's container, simply replace the usual run subcommand with the container run subcommand. Project and experiment selection are done in the same way. Example: benchbuild container run -E raw linpack [1] ( ) ( ) This will run the following stages: Build all necessary base images. All images are initiated from a base image. Benchbuild knows how to construct a few base images. These will be prepared with all dependencies required to run benchbuild inside the container. Build all project images. Each project has to define its' own image. Build the experiment images. Each experiment can add anything it needs to the project images, if required. Use this to bring tools into the image that do not require any knowledge about the environment to run properly. For anything else, consider using a custom base image. Replace Images Benchbuild will reuse any existing images it can find in your image registry. The only relevant information is the image tag, e.g., benchbuild:alpine . If you want to avoid reuse and force to rebuild images unconditionally, you can use the --replace flag when running the containers subcommand. Example: benchbuild container run --replace -E raw linpack [2] ( ) ( ) This will ignore any required image for the given experiments and projects. Configuration You can configure the container environment using the following config variables. BB_CONTAINER_EXPORT : Path where benchbuild stores exported container images. By default we store it in ./containers/export . Will be created automatically, if needed. BB_CONTAINER_IMPORT : Path where to input images from into the registry. By default we load from ./containers/export . BB_CONTAINER_FROM_SOURCE : Determine, if we should use benchbuild from the current source checkout, or from pip. BB_CONTAINER_ROOT : Where we store our image layers. This is the image registry. Cannot be stored on filesystems that do not support subuid/-gid mapping, e.g. NFS. The default location is ./containers/lib . BB_CONTAINER_RUNROOT : Where we store temporary image layers of running containers. See BB_CONTAINER_ROOT for restrictions. The default location is: ./containers/run . BB_CONTAINER_RUNTIME : Podman can use any standard OCI-container runtime to launch containers. We use crun by default. Depending on your system, this one has already been installed with podman . The default runtime is: /usr/bin/crun BB_CONTAINER_MOUNTS : A list of mountpoint definitions that should be added to all containers. With this you can add arbitrary tools into all containers. Default: [] Definition A project that wants to use a container image needs to define it in the CONTAINER attribute it using our declarative API provided by benchbuild.environments.domain.declarative . from benchbuild.environments.domain.declarative import ContainerImage class Testproject(Project): CONTAINER = ContainerImage().from_('benchbuild:alpine') [3] ( ) ( ) The available set of commands follows the structure of a Dockerfile . Runtime requirements For containers to work properly, you need a few systems set up beforehand. Buildah Image construction requires the Buildah tool. All image construction tasks are formulated as buildah command calls in the backend. Buildah is supported up to version 1.19.8. Podman Container construction and execution is handed off to Podman . Podman provides rootless containers and does not requires the execution of a daemon process. However, you need to setup your user namespace properly to allow mapping of subordinate uids/gids. Otherwise, podman will not be able to map users other than the root user to filesystem permissions inside the container. Please refer to podman's documentation on how to setup podman properly on your system. Podman is supported up to version 2.2.1","title":"Containers"},{"location":"basics/containers/#usage","text":"If you want to run an experiment inside the project's container, simply replace the usual run subcommand with the container run subcommand. Project and experiment selection are done in the same way. Example: benchbuild container run -E raw linpack [1] ( ) ( ) This will run the following stages: Build all necessary base images. All images are initiated from a base image. Benchbuild knows how to construct a few base images. These will be prepared with all dependencies required to run benchbuild inside the container. Build all project images. Each project has to define its' own image. Build the experiment images. Each experiment can add anything it needs to the project images, if required. Use this to bring tools into the image that do not require any knowledge about the environment to run properly. For anything else, consider using a custom base image.","title":"Usage"},{"location":"basics/containers/#replace-images","text":"Benchbuild will reuse any existing images it can find in your image registry. The only relevant information is the image tag, e.g., benchbuild:alpine . If you want to avoid reuse and force to rebuild images unconditionally, you can use the --replace flag when running the containers subcommand. Example: benchbuild container run --replace -E raw linpack [2] ( ) ( ) This will ignore any required image for the given experiments and projects.","title":"Replace Images"},{"location":"basics/containers/#configuration","text":"You can configure the container environment using the following config variables. BB_CONTAINER_EXPORT : Path where benchbuild stores exported container images. By default we store it in ./containers/export . Will be created automatically, if needed. BB_CONTAINER_IMPORT : Path where to input images from into the registry. By default we load from ./containers/export . BB_CONTAINER_FROM_SOURCE : Determine, if we should use benchbuild from the current source checkout, or from pip. BB_CONTAINER_ROOT : Where we store our image layers. This is the image registry. Cannot be stored on filesystems that do not support subuid/-gid mapping, e.g. NFS. The default location is ./containers/lib . BB_CONTAINER_RUNROOT : Where we store temporary image layers of running containers. See BB_CONTAINER_ROOT for restrictions. The default location is: ./containers/run . BB_CONTAINER_RUNTIME : Podman can use any standard OCI-container runtime to launch containers. We use crun by default. Depending on your system, this one has already been installed with podman . The default runtime is: /usr/bin/crun BB_CONTAINER_MOUNTS : A list of mountpoint definitions that should be added to all containers. With this you can add arbitrary tools into all containers. Default: []","title":"Configuration"},{"location":"basics/containers/#definition","text":"A project that wants to use a container image needs to define it in the CONTAINER attribute it using our declarative API provided by benchbuild.environments.domain.declarative . from benchbuild.environments.domain.declarative import ContainerImage class Testproject(Project): CONTAINER = ContainerImage().from_('benchbuild:alpine') [3] ( ) ( ) The available set of commands follows the structure of a Dockerfile .","title":"Definition"},{"location":"basics/containers/#runtime-requirements","text":"For containers to work properly, you need a few systems set up beforehand.","title":"Runtime requirements"},{"location":"basics/containers/#buildah","text":"Image construction requires the Buildah tool. All image construction tasks are formulated as buildah command calls in the backend. Buildah is supported up to version 1.19.8.","title":"Buildah"},{"location":"basics/containers/#podman","text":"Container construction and execution is handed off to Podman . Podman provides rootless containers and does not requires the execution of a daemon process. However, you need to setup your user namespace properly to allow mapping of subordinate uids/gids. Otherwise, podman will not be able to map users other than the root user to filesystem permissions inside the container. Please refer to podman's documentation on how to setup podman properly on your system. Podman is supported up to version 2.2.1","title":"Podman"},{"location":"concepts/environments/","text":"Environment","title":"Environment"},{"location":"concepts/environments/#environment","text":"","title":"Environment"},{"location":"concepts/experiments/","text":"Experiment TODO.","title":"Experiment"},{"location":"concepts/experiments/#experiment","text":"TODO.","title":"Experiment"},{"location":"concepts/projects/","text":"Project TODO.","title":"Project"},{"location":"concepts/projects/#project","text":"TODO.","title":"Project"},{"location":"concepts/source/","text":"Source TODO. General Versioning HTTP Git Rsync TODO.","title":"Source"},{"location":"concepts/source/#source","text":"TODO.","title":"Source"},{"location":"concepts/source/#general","text":"","title":"General"},{"location":"concepts/source/#versioning","text":"","title":"Versioning"},{"location":"concepts/source/#http","text":"","title":"HTTP"},{"location":"concepts/source/#git","text":"","title":"Git"},{"location":"concepts/source/#rsync","text":"TODO.","title":"Rsync"}]}